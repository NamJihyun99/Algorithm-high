## 순차 탐색 Sequential Search

: 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법

- 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용
- 리스트 내에 데이터가 아무리 많아도, 시간만 충분하다면 항상 원하는 원소를 찾을 수 있다.
- 최악의 경우 O(N)

## 이진 탐색 Binary Search

: 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 방법

- 리스트 데이터가 정렬되어 있을 때, 매우 빠르게 데이터를 찾을 수 있다.
- O(logN)
- 탐색 범위가 1,000만을 넘어가면 이진탐색으로 접근해보자.

## 트리 자료구조

- 트리는 부모노드와 자식 노드의 관계로 표현된다.
- 트리의 최상단 노드를 루트 노드라고 한다.
- 트리의 최하단 노드를 단말 노드라고 한다.
- 트리의 일부를 떼어내도 트리 구조이며 이를 서브 트리라고 한다.
- 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.

## 이진 탐색 트리

: 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.

<aside>
🌲 - 부모 노드보다 왼쪽 자식 노드가 작다
- 부모 노드보다 오른쪽 자식 노드가 크다
**⇒ 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드**

</aside>

## 이진 탐색 시 주의 할 점

1. 탈출 조건 반복문에서 `low ≤ high`, `low < high`, `low + 1 < high` 등의 조건식을 작성하게 되는데 이를 잘못 작성하지 않았는지 의심해 봅시다.
2. 초깃값 설정 반복문 진입 전, `low`와 `high`의 값을 설정할 때 유의해야 합니다. 문제의 답이 얼마나 작아질 수 있는지, 또는 얼마나 커질 수 있을지 헤아려 봅시다.
3. 중간값 설정
    1. 중간값을 택할 때 `mid = (low + high) / 2`이나 `mid = (low + high + 1) / 2` 등의 식을 작성합니다. 이 또한 정답은 없으며 본인의 구현 방식에 맞게끔 작성하면 됩니다.
    2. `mid`를 구할 때 정수 오버플로우에 유의해야 합니다.
        
        예를 들어 문제의 정답이 int 범위 내여도 계산 과정에서 int 범위를 벗어날 수 있습니다. 즉, `low`, `high`가 int 범위 이내여도 (`low` + `high`)는 오버플로우가 일어날 수 있습니다.
        
        그럼 어떻게 해야 할까요? int 대신에 long long을 사용하면 될까요? 만약 답은 long long 이내이지만 계산 과정에서 low와 high가 모두 long long의 최댓값에 근접하여 이 또한 오버플로우를 낸다면?
        
        간단한 대안으로 다음과 같이 코드를 작성한다면 오버플로우 없이 중간값을 구할 수 있습니다.
        
        `mid = low + (high - low) / 2`
        
4. `low`, `high` 갱신
    
    탐색 범위를 좁힐 때 `low`를 위로 올리거나 `high`를 아래로 내리게 되는데, 이때 `low = mid`, `low = mid + 1`, `high = mid`, `high = mid - 1` 등으로 작성하게 됩니다. 이때도 정답은 없으며 본인의 구현 방식에 맞게 작성하면 됩니다.
    
5. 정답의 선택
    
    반복문을 빠져나온 후 이분 탐색의 결과로 `low`, `high`, `(low + high) / 2` 중 뭐가 맞을까요? 아님 따로 `answer` 변수를 선언하여 반복문 안에서 갱신하는 게 맞을까요? 정답은 없습니다. 본인의 구현 방식에 맞는 방법을 택하길 바랍니다.
