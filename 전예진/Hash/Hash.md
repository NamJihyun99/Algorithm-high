# 해시 (Hash) - 딕셔너리 (Dictionary)


## 해시 테이블 : O(1)

> **Key:Value** 형태로 데이터를 저장하는 자료구조

### Q. 해시가 없던 시절에는?

```python
int[] phonebook = new int[5];
phonebook[0]
```

- 배열을 사용해서 전화 번호를 저장할 수 있었고, 해당 정수를 통해 전화번호를 찾을 수 있음
- 하지만 이름을 기반으로 전화번호를 찾을 수 없음 → for문을 모두 돌면서 전화번호를 찾아야 함

```python
phonebook['yejin'] = '01012341234'
```

- 하지만 해시는 **모든 데이터 타입으로 접근이 가능**하다!

## 동작 방식
<img width="716" alt="스크린샷 2023-11-20 오후 9 51 10" src="https://github.com/yaezzin/ps-study/assets/97823928/d369c47a-c5ea-46f3-ba83-8cd8b93ba3a6">


1. key에 해당하는 임의 길이인 값을 해시 함수에 넣으면 고정된 길이의 데이터로 변환이 된다
    - 즉, 해시 함수는 임의 길이 데이터를 암호화된 고정 길이 데이터로 전환하는 함수이다.

2. 버킷에 키 값은 해시 함수에서 얻은 값을 인덱스로 사용하고, 값은 우리가 원래 배열에 넣고 싶었던 데이터를 넣어준다.
    
    → `해시 테이블` : 해시 함수에 넣어 얻은 해시를 인덱스로 하여, value 데이터와 매핑하는 array(table) 형태의 자료구조
    

### Q. **언제 해시를 사용하는 것이 좋을까?**

1. **리스트를 쓸 수 없을 때** 
    - 인덱스 값을 숫자가 아닌 다른 값 '문자열, 튜플'을 사용하려고 할 때 딕셔너리(해시)를 사용
    - **String을 기반으로 정보를 기록하고 관리할 때 → 즉, key가 string일 때 사용하자**
2. **빠른 접근  / 탐색이 필요할 때**
    - 딕셔너리 함수의 시간복잡도는 대부분 O(1)
3. **원소의 개수를 세거나, 해당 원소가 존재하는지 확인할 때!!**
    - 리스트를 사용하는 경우 시간 초과가나는 경우 딕셔너리를 사용하는 것이 좋다.

## 시간복잡도
<img width="690" alt="스크린샷 2023-11-20 오후 9 50 57" src="https://github.com/yaezzin/ps-study/assets/97823928/f9eb5804-2c39-464c-b357-22555f73b38f">


💥 **해시 테이블의 시간 복잡도가 일반적으로 O(1)인 이유 ??**

- 해시 함수를 통해 해시값을 계산하고, 이를 배열의 인덱스로 사용하여 데이터에 접근할 수 있기 때문
- 해시 함수의 계산은 단순히 나머지 계산이기 때문에 상수 시간에 이루어지며, 배열의 인덱스로 직접 접근할 수 있으므로 데이터에 대한 검색, 삽입, 삭제가 상수 시간에 이루어짐
- 하지만 **충돌이 발생하는 경우 O(N)**이 될 수 있다!

## 충돌

> 여러 개의 키 값이 해시 함수를 통해 같은 해시 값을 가지는 경우
> 
- 자바에서는 `Chaining` 방법을, 파이썬에서는 `Open Addressing` 방법을 사용해서 충돌을 해결한다.

### 1. Chaining
<img width="355" alt="스크린샷 2023-11-20 오후 9 50 41" src="https://github.com/yaezzin/ps-study/assets/97823928/a5674c6a-b2d0-4452-9354-1f573880abf7">


- 충돌이 발생하면, 버킷에 **연결리스트**를 통해 연결하여 충돌을 해결
- 하지만 모든 값들이 만약 0번 인덱스에 연결되어있다면, 연결 리스트 내에서 하나하나 O(N)으로 찾아가야 하므로 최악의 케이스에는 O(N)이 나오게 되는 것이다.

### 2. Open Addressing

- 충돌이 발생하면, 다른 빈공간에 가서 데이터를 채워넣는 방식으로 충돌을 해결
    - 하지만 넣는 위치가 원래 key를 해시함수에 넣어 얻은 인덱스와 다르기 때문에 체이닝 방법과 달리 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없다!
- 따라서 **충돌이 발생하면 해당 위치부터 순차적으로 탐사를 하나씩 진행하며 빈공간을 발견하면 그 자리에 바로 삽입한다 → 선형 탐색**
- 하지만 최악의 경우 충돌이 반복되어, **동일한 해시값을 가지는 데이터들이 연속적으로 모여있는 현상이 발생할 수 있음 → 클러스터화**
    - **이로 인해 해시 테이블의 특정 영역에 데이터가 몰리게 되면 한쪽으로 편중되고 다른 쪽에는 데이터가 거의 없다. 이렇게 클러스터링 현상이 생기면 탐사 시간이 오래 걸린다.**


## 딕셔너리 사용법

파이썬에서 해시를 구현하는 방법은 `딕셔너리(Dictionary)` 자료구조를 이용하는 것이다.

### 1. 선언

```python
from collections import dict

dict1 = {}
dict2 = dict()
```

### 2. 조회

```python
dict = {'하이': 300, '헬로': 180, 3: 5}

dict['하이']
dict.get('하이', 0)
```

- **dict[key]**
- **dict.get(key, value)**
    - 해당 키를 가지는 값을 가져오되, 없다면 Error 대신 value을 가져오도록 설정할 수 있다.

### 3. key, value 조회

```python
dict.keys()   # key만 조회하기
dict.values() # 값만 조회하기
dict.items()  # 둘다 조회
```

### 4. 삽입/수정

```python
dict = {'하이': 300, '헬로': 180}

dict['바이'] = 400
dict['하이'] = 7012
```

### 5. 삭제

```python
del dict['하이']
dict.pop('하이', 200)
```

- **del** **dict[key]**
- **dict.pop(key, value)**
    - 해당 키를 가지는 값을 삭제하되 없다면 Error 대신 value을 리턴한다.
    

### 6.  Iterate

**6-1 ) key로만 순회하기** 

```python
dict = {'하이': 300, '헬로': 180}

for key in dict:
    print(key)

# 하이
# 헬로
```

**6-2 ) key, value 동시 순회하기**

```python
dict = {'하이': 300, '헬로': 180}

for key, value in dict.items():
    print(key, value)
```

- dict.items()를 사용하자

### 6. 정렬하기

```python
dict = {'하이': 300, '헬로': 180}

sorted_dict1 = {key:dict[key] for key in sorted(dict) }
sorted_dict2 = {key:dict[key] for key in sorted(dict,reverse=True)}
sorted_dict3 = sorted(dict.items(), key=lambda x : x[0])
```

- 여러가지 방법이 있으나, 마지막에 제일 간결하다.

### 7. 초기화

**7-1 ) 모든 key에 대해  값을 1로 초기화하고 싶다면?**

```python
dic = {key:1 for key in input().split()}
```

**7-2 ) key에 대한 개수만큼 값을 초기화하고 싶다면?**

- `Counter`을 사용하자
